using SerousEnergyLib.API.Energy;
using SerousEnergyLib.API.Energy.Default;
using SerousEnergyLib.API.Fluid;
using SerousEnergyLib.API.Fluid.Default;
using SerousEnergyLib.API.Machines;
using SerousEnergyLib.Items.Materials;
using SerousEnergyLib.Tiles;
using System;
using System.Collections.Generic;
using System.Linq;
using Terraria;
using Terraria.Localization;
using Terraria.ModLoader;
using Terraria.ModLoader.Exceptions;
using Terraria.ModLoader.IO;

namespace SerousEnergyLib.API {
	#pragma warning disable CS1591
	/// <summary>
	/// An object representing a set of recipes for "input to output" in a machine
	/// </summary>
	public class MachineRecipe {
		/// <summary>
		/// The machine tile that this recipe is used by
		/// </summary>
		public int MachineTile { get; protected set; }

		private readonly List<IMachineRecipeIngredient> ingredients = new();
		/// <summary>
		/// A collection of the ingredients for this recipe
		/// </summary>
		public IReadOnlyList<IMachineRecipeIngredient> Ingredients => ingredients.AsReadOnly();

		private readonly List<MachineRecipeOutput> possibleOutputs = new();
		/// <summary>
		/// A collection of all possible output items generated by this recipe
		/// </summary>
		public IReadOnlyList<MachineRecipeOutput> PossibleOutputs => possibleOutputs.AsReadOnly();

		private readonly IMachineRecipeIngredient duration;

		/// <summary>
		/// Gets the time range assigned to this recipe
		/// </summary>
		public (Ticks min, Ticks max) Duration {
			get {
				if (duration is MachineRecipeInputTime time)
					return (time.time, time.time);
				else if (duration is MachineRecipeInputTimeRange range)
					return (range.minimumTime, range.maximumTime);

				return (Ticks.Zero, Ticks.Zero);
			}
		}

		protected private MachineRecipe(Ticks duration) {
			this.duration = new MachineRecipeInputTime(duration);
		}

		protected private MachineRecipe(Ticks minimumDuration, Ticks maximumDuration) {
			duration = new MachineRecipeInputTimeRange(minimumDuration, maximumDuration);
		}

		public MachineRecipe(int machine, Ticks duration) {
			if (TileLoader.GetTile(machine) is not BaseMachineTile)
				throw new ArgumentException("Tile ID did not refer to a BaseMachineTile instance", nameof(machine));

			MachineTile = machine;
			this.duration = new MachineRecipeInputTime(duration);
		}

		public MachineRecipe(int machine, Ticks minimumDuration, Ticks maximumDuration) {
			if (TileLoader.GetTile(machine) is not BaseMachineTile)
				throw new ArgumentException("Tile ID did not refer to a BaseMachineTile instance", nameof(machine));

			MachineTile = machine;
			duration = new MachineRecipeInputTimeRange(minimumDuration, maximumDuration);
		}

		/// <inheritdoc cref="Recipe.AddIngredient(int, int)"/>
		public MachineRecipe AddIngredient(int type, int stack = 1) {
			ingredients.Add(new MachineRecipeInputItem(type, stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddIngredient{T}(int)"/>
		public MachineRecipe AddIngredient<T>(int stack = 1) where T : ModItem {
			ingredients.Add(new MachineRecipeInputItem(ModContent.ItemType<T>(), stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddRecipeGroup(string, int)"/>
		public MachineRecipe AddRecipeGroup(string group, int stack = 1) {
			ingredients.Add(new MachineRecipeInputRecipeGroup(group, stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddRecipeGroup(int, int)"/>
		public MachineRecipe AddRecipeGroup(int group, int stack = 1) {
			ingredients.Add(new MachineRecipeInputRecipeGroup(group, stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddRecipeGroup(RecipeGroup, int)"/>
		public MachineRecipe AddRecipeGroup(RecipeGroup group, int stack = 1) {
			ingredients.Add(new MachineRecipeInputRecipeGroup(group.ID, stack));
			return this;
		}

		/// <summary>
		/// Adds a possible output to this recipe with the given item type, stack size and probability. Ex: <c>recipe.AddPossibleOutput(ItemID.IronAxe, 0.25)</c>
		/// </summary>
		/// <param name="type">The item identifier.</param>
		/// <param name="stack">The stack.</param>
		/// <param name="chance">The chance displayed when viewing this recipe</param>
		public MachineRecipe AddPossibleOutput(int type, int stack = 1, double chance = 1.0) {
			possibleOutputs.Add(new MachineRecipeOutput(type, stack, chance));
			return this;
		}

		/// <summary>
		/// Adds a possible output to this recipe with the given item type, stack size and probability.
		/// </summary>
		/// <param name="stack">The stack.</param>
		/// <param name="chance">The chance displayed when viewing this recipe</param>
		public MachineRecipe AddPossibleOutput<T>(int stack = 1, double chance = 1.0) where T : ModItem {
			possibleOutputs.Add(new MachineRecipeOutput(ModContent.ItemType<T>(), stack, chance));
			return this;
		}

		/// <summary>
		/// Creates all possible recipes based on this instance's ingredients and possible outputs
		/// </summary>
		public MachineRecipe CreateAndRegisterAllPossibleRecipes() {
			foreach (var output in possibleOutputs) {
				Recipe recipe = Recipe.Create(output.type, output.stack);

				foreach (var input in ingredients)
					input.AddToRecipe(recipe);

				duration.AddToRecipe(recipe);

				recipe.AddTile(MachineTile);

				string chanceString = output.chance >= 0.01 ? $"{output.chance * 100:0.###}" : "<1";

				recipe.AddCondition(new Recipe.Condition(NetworkText.FromKey("Mods.SerousEnergyLib.RecipeChanceOutput", chanceString), static r => false));

				recipe.Register();
			}

			return this;
		}

		/// <summary>
		/// Checks if the contents of <paramref name="machine"/> can satisfy any of this recipe's requirements
		/// </summary>
		/// <param name="machine"></param>
		/// <returns>Whether all of the requirements for this recipe can be satisfied by the machine's contents</returns>
		public bool IngredientSetMatches(IMachine machine) {
			MachineRecipeState state = new(machine);

			// Copy the ingredients, modify them, then use them
			var modifiedIngredients = new List<IMachineRecipeIngredient>(ingredients);

			foreach (var upgradeItem in machine.Upgrades) {
				var upgrade = upgradeItem.Upgrade;

				if (!upgrade.CanApplyTo(machine))
					continue;

				for (int i = 0; i < modifiedIngredients.Count; i++) {
					IMachineRecipeIngredient obj = modifiedIngredients[i];
					upgrade.ModifyMachineRecipeIngredient(ref obj, Ingredients, PossibleOutputs);
					modifiedIngredients[i] = obj;
				}
			}

			return modifiedIngredients.All(i => i.IsIngredientRequirementMet(machine, state));
		}
	}

	/// <inheritdoc cref="MachineRecipe"/>
	public sealed class MachineRecipe<T> : MachineRecipe where T : BaseMachineTile {
		public MachineRecipe(Ticks duration) : base(duration) {
			MachineTile = ModContent.TileType<T>();
		}
	}

	public interface IMachineRecipeIngredient {
		void AddToRecipe(Recipe recipe);

		bool IsIngredientRequirementMet(IMachine source, MachineRecipeState state);
	}

	/// <summary>
	/// A structure representing an item ingredient in a recipe
	/// </summary>
	public readonly struct MachineRecipeInputItem : IMachineRecipeIngredient {
		public readonly int type;
		public readonly int stack;

		public MachineRecipeInputItem(int type, int stack) {
			this.type = type;
			this.stack = stack;
		}

		public void AddToRecipe(Recipe recipe) => recipe.AddIngredient(type, stack);

		public bool IsIngredientRequirementMet(IMachine source, MachineRecipeState state) {
			int remaining = stack;

			foreach (Item item in state.items) {
				if (item.IsAir)
					continue;

				if (item.type == type) {
					int toRemove = Math.Min(remaining, item.stack);

					remaining -= toRemove;
					item.stack -= toRemove;

					if (remaining <= 0)
						return true;
				}
			}

			return false;
		}
	}

	/// <summary>
	/// A structure representing a recipe group ingredient in a recipe
	/// </summary>
	public readonly struct MachineRecipeInputRecipeGroup  : IMachineRecipeIngredient {
		public readonly int group;
		public readonly int stack;

		public MachineRecipeInputRecipeGroup(string group, int stack) {
			if (!RecipeGroup.recipeGroupIDs.TryGetValue(group, out int id))
				throw new RecipeException($"RecipeGroup with string ID \"{group}\" does not exist");

			this.group = id;
			this.stack = stack;
		}

		public MachineRecipeInputRecipeGroup(int group, int stack) {
			if (!RecipeGroup.recipeGroups.ContainsKey(group))
				throw new RecipeException($"RecipeGroup with integer ID {group} does not exist");

			this.group = group;
			this.stack = stack;
		}

		public void AddToRecipe(Recipe recipe) => recipe.AddRecipeGroup(group, stack);

		public bool IsIngredientRequirementMet(IMachine source, MachineRecipeState state) {
			int remaining = stack;

			if (!RecipeGroup.recipeGroups.TryGetValue(group, out RecipeGroup recipeGroup))
				return false;

			foreach (Item item in state.items) {
				if (item.IsAir)
					continue;

				if (recipeGroup.ValidItems.Contains(item.type)) {
					int toRemove = Math.Min(remaining, item.stack);

					remaining -= toRemove;
					item.stack -= toRemove;

					if (remaining <= 0)
						return true;
				}
			}

			return false;
		}
	}

	public readonly struct MachineRecipeInputFluid : IMachineRecipeIngredient {
		public readonly int type;
		public readonly int amountInMilliliters;

		public MachineRecipeInputFluid(int fluidType, double liters) {
			if (FluidLoader.Get(fluidType) is not FluidTypeID id || id is UnloadedFluidID)
				throw new ArgumentException("Fluid type ID for ingredient was invalid", nameof(fluidType));

			if (ItemLoader.GetItem(id.RecipeItemType) is not FluidRecipeItem)
				throw new ArgumentException($"Fluid type ID \"{id.GetPrintedDisplayName()}\" had an invalid item ID for its RecipeItemType property");

			if (liters < 0.001)
				throw new ArgumentException("Fluid quantity must be greater than or equal to 1 milliliter");

			type = fluidType;
			amountInMilliliters = (int)(liters * 1000d);
		}

		public void AddToRecipe(Recipe recipe) {
			var id = FluidLoader.Get(type);

			recipe.AddIngredient(id.RecipeItemType, amountInMilliliters);
		}

		public bool IsIngredientRequirementMet(IMachine source, MachineRecipeState state) {
			double liters = amountInMilliliters / 1000d;
			foreach (var storage in state.fluids) {
				if (storage.FluidType != type)
					continue;

				double export = liters;
				storage.Export(ref liters, out _);

				liters -= export;

				if (liters <= 0)
					return true;
			}

			return false;
		}
	}

	public readonly struct MachineRecipeInputPower : IMachineRecipeIngredient {
		public readonly int amount;
		public readonly int type;

		public MachineRecipeInputPower(TerraFlux flux) {
			if (flux <= TerraFlux.Zero)
				throw new ArgumentOutOfRangeException(nameof(flux));

			amount = (int)(double)flux;
			type = SerousMachines.EnergyType<TerraFluxTypeID>();
		}

		public MachineRecipeInputPower(int amount, int energyType) {
			if (EnergyConversions.Get(energyType) is not EnergyTypeID id)
				throw new ArgumentException("Energy type ID for ingredient was invalid");

			if (ItemLoader.GetItem(id.RecipeItemType) is not EnergyRecipeItem)
				throw new ArgumentException($"Energy type ID \"{id.GetPrintedDisplayName()}\" had an invalid item ID for its RecipeItemType property");

			if (amount <= 0)
				throw new ArgumentOutOfRangeException(nameof(amount));

			this.amount = amount;
			type = energyType;
		}

		public void AddToRecipe(Recipe recipe) {
			var id = EnergyConversions.Get(type);

			recipe.AddIngredient(id.RecipeItemType, amount);
		}

		public bool IsIngredientRequirementMet(IMachine source, MachineRecipeState state) {
			TerraFlux flux = EnergyConversions.ConvertToTerraFlux(amount, type);
			TerraFlux export = flux;

			state.power.Export(ref export);

			return flux - export <= TerraFlux.Zero;
		}
	}

	public readonly struct MachineRecipeInputTime : IMachineRecipeIngredient {
		public readonly Ticks time;

		public MachineRecipeInputTime(Ticks time) {
			if (time.ticks <= 0)
				throw new ArgumentOutOfRangeException(nameof(time));

			this.time = time;
		}

		public void AddToRecipe(Recipe recipe) => recipe.AddIngredient<TimeRecipeItem>(time.ticks);

		public bool IsIngredientRequirementMet(IMachine source, MachineRecipeState state) => true;  // The duration is checked in the machine's logic instead of here
	}

	public readonly struct MachineRecipeInputTimeRange : IMachineRecipeIngredient {
		public readonly Ticks minimumTime;
		public readonly Ticks maximumTime;

		public MachineRecipeInputTimeRange(Ticks minimumTime, Ticks maximumTime) {
			if (minimumTime.ticks > maximumTime.ticks)
				throw new ArgumentException(nameof(minimumTime), "Minimum time must be less than or equal to maximum time");

			if (minimumTime.ticks <= 0)
				throw new ArgumentOutOfRangeException(nameof(minimumTime));

			this.minimumTime = minimumTime;
			this.maximumTime = maximumTime;
		}

		public void AddToRecipe(Recipe recipe) {
			recipe.AddIngredient<TimeMinimumRangeRecipeItem>(minimumTime.ticks);
			recipe.AddIngredient<TimeMaximumRangeRecipeItem>(maximumTime.ticks);
		}

		public bool IsIngredientRequirementMet(IMachine source, MachineRecipeState state) => true;  // The duration is checked in the machine's logic instead of here
	}

	/// <summary>
	/// A structure representing an output item with a probability
	/// </summary>
	public readonly struct MachineRecipeOutput {
		public readonly int type;
		public readonly int stack;
		public readonly double chance;

		public MachineRecipeOutput(int type, int stack, double chance = 1.0) {
			this.type = type;
			this.stack = stack;
			this.chance = Utils.Clamp(chance, 0, 1);
		}
	}

	/// <summary>
	/// A collection of information that's passed to <see cref="IMachineRecipeIngredient.IsIngredientRequirementMet(IMachine, MachineRecipeState)"/>
	/// </summary>
	public sealed class MachineRecipeState {
		public readonly Item[] items;
		public readonly FluidStorage[] fluids;
		public readonly FluxStorage power;

		internal MachineRecipeState(IMachine machine) {
			// Get the item inventory
			Item[] inventoryItems;
			if (machine is IInventoryMachine inventory) {
				inventoryItems = inventory.Inventory;

				if (inventoryItems is null)
					throw new ArgumentException("Item inventory array was null");
			} else
				inventoryItems = Array.Empty<Item>();

			// Get the fluid inventory
			FluidStorage[] storageFluids;
			if (machine is IFluidMachine fluid) {
				storageFluids = fluid.FluidStorage;

				if (storageFluids is null)
					throw new ArgumentException("Fluid storage array was null");
			} else
				storageFluids = Array.Empty<FluidStorage>();

			// Get the power inventory
			power = new FluxStorage(TerraFlux.Zero);
			if (machine is IPoweredMachine powered) {
				if (powered.PowerStorage is null)
					throw new ArgumentException("Power storage was null");

				TagCompound tag = new TagCompound();
				powered.PowerStorage.SaveData(tag);
				power.LoadData(tag);
			}

			// Clone the collections since they'll be clobbered later
			if (inventoryItems.Length > 0) {
				items = new Item[inventoryItems.Length];

				for (int i = 0; i < items.Length; i++)
					items[i] = inventoryItems[i].Clone();
			} else
				items = inventoryItems;

			if (storageFluids.Length > 0) {
				fluids = new FluidStorage[storageFluids.Length];

				for (int i = 0; i < fluids.Length; i++) {
					FluidStorage storage = new(0);

					TagCompound tag = new();
					storageFluids[i].SaveData(tag);
					storage.LoadData(tag);

					fluids[i] = storage;
				}
			} else
				fluids = storageFluids;
		}
	}
}
