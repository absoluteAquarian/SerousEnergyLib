using SerousEnergyLib.Tiles;
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.Localization;
using Terraria.ModLoader;
using Terraria.ModLoader.Exceptions;

namespace SerousEnergyLib.API {
	#pragma warning disable CS1591
	/// <summary>
	/// An object representing a set of recipes for "input to output" in a machine
	/// </summary>
	public class MachineRecipe {
		/// <summary>
		/// The machine tile that this recipe is used by
		/// </summary>
		public int MachineTile { get; protected set; }

		private readonly List<IMachineRecipeIngredient> ingredients = new();
		/// <summary>
		/// A collection of the ingredients for this recipe
		/// </summary>
		public IReadOnlyList<IMachineRecipeIngredient> Ingredients => ingredients.AsReadOnly();

		private readonly List<MachineRecipeOutput> possibleOutputs = new();
		/// <summary>
		/// A collection of all possible output items generated by this recipe
		/// </summary>
		public IReadOnlyList<MachineRecipeOutput> PossibleOutputs => possibleOutputs.AsReadOnly();

		protected private MachineRecipe() { }

		public MachineRecipe(int machine) {
			if (TileLoader.GetTile(machine) is not BaseMachineTile)
				throw new ArgumentException("Tile ID did not refer to a BaseMachineTile instance", nameof(machine));

			MachineTile = machine;
		}

		/// <inheritdoc cref="Recipe.AddIngredient(int, int)"/>
		public MachineRecipe AddIngredient(int type, int stack = 1) {
			ingredients.Add(new MachineRecipeInputItem(type, stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddIngredient{T}(int)"/>
		public MachineRecipe AddIngredient<T>(int stack = 1) where T : ModItem {
			ingredients.Add(new MachineRecipeInputItem(ModContent.ItemType<T>(), stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddRecipeGroup(string, int)"/>
		public MachineRecipe AddRecipeGroup(string group, int stack = 1) {
			ingredients.Add(new MachineRecipeInputRecipeGroup(group, stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddRecipeGroup(int, int)"/>
		public MachineRecipe AddRecipeGroup(int group, int stack = 1) {
			ingredients.Add(new MachineRecipeInputRecipeGroup(group, stack));
			return this;
		}

		/// <inheritdoc cref="Recipe.AddRecipeGroup(RecipeGroup, int)"/>
		public MachineRecipe AddRecipeGroup(RecipeGroup group, int stack = 1) {
			ingredients.Add(new MachineRecipeInputRecipeGroup(group.ID, stack));
			return this;
		}

		/// <summary>
		/// Adds a possible output to this recipe with the given item type, stack size and probability. Ex: <c>recipe.AddPossibleOutput(ItemID.IronAxe, 0.25)</c>
		/// </summary>
		/// <param name="type">The item identifier.</param>
		/// <param name="stack">The stack.</param>
		/// <param name="chance">The chance displayed when viewing this recipe</param>
		public MachineRecipe AddPossibleOutput(int type, int stack = 1, double chance = 1.0) {
			possibleOutputs.Add(new MachineRecipeOutput(type, stack, chance));
			return this;
		}

		/// <summary>
		/// Adds a possible output to this recipe with the given item type, stack size and probability.
		/// </summary>
		/// <param name="stack">The stack.</param>
		/// <param name="chance">The chance displayed when viewing this recipe</param>
		public MachineRecipe AddPossibleOutput<T>(int stack = 1, double chance = 1.0) where T : ModItem {
			possibleOutputs.Add(new MachineRecipeOutput(ModContent.ItemType<T>(), stack, chance));
			return this;
		}

		/// <summary>
		/// Creates all possible recipes based on this instance's ingredients and possible outputs
		/// </summary>
		public MachineRecipe CreateAndRegisterAllPossibleRecipes() {
			foreach (var output in possibleOutputs) {
				Recipe recipe = Recipe.Create(output.type, output.stack);

				foreach (var input in ingredients)
					input.AddToRecipe(recipe);

				recipe.AddTile(MachineTile);

				string chanceString = output.chance >= 0.01 ? $"{output.chance * 100:0.###}" : "<1";

				recipe.AddCondition(new Recipe.Condition(NetworkText.FromKey("Mods.SerousEnergyLib.RecipeChanceOutput", chanceString), static r => false));

				recipe.Register();
			}

			return this;
		}
	}

	/// <inheritdoc cref="MachineRecipe"/>
	public sealed class MachineRecipe<T> : MachineRecipe where T : BaseMachineTile {
		public MachineRecipe() : base() {
			MachineTile = ModContent.TileType<T>();
		}
	}

	public interface IMachineRecipeIngredient {
		void AddToRecipe(Recipe recipe);
	}

	/// <summary>
	/// A structure representing an item ingredient in a recipe
	/// </summary>
	public readonly struct MachineRecipeInputItem : IMachineRecipeIngredient {
		public readonly int type;
		public readonly int stack;

		public MachineRecipeInputItem(int type, int stack) {
			this.type = type;
			this.stack = stack;
		}

		public void AddToRecipe(Recipe recipe) => recipe.AddIngredient(type, stack);
	}

	/// <summary>
	/// A structure representing a recipe group ingredient in a recipe
	/// </summary>
	public readonly struct MachineRecipeInputRecipeGroup  : IMachineRecipeIngredient {
		public readonly int group;
		public readonly int stack;

		public MachineRecipeInputRecipeGroup(string group, int stack) {
			if (!RecipeGroup.recipeGroupIDs.TryGetValue(group, out int id))
				throw new RecipeException($"RecipeGroup with string ID \"{group}\" does not exist");

			this.group = id;
			this.stack = stack;
		}

		public MachineRecipeInputRecipeGroup(int group, int stack) {
			if (!RecipeGroup.recipeGroups.ContainsKey(group))
				throw new RecipeException($"RecipeGroup with integer ID {group} does not exist");

			this.group = group;
			this.stack = stack;
		}

		public void AddToRecipe(Recipe recipe) => recipe.AddRecipeGroup(group, stack);
	}

	/// <summary>
	/// A structure representing an output item with a probability
	/// </summary>
	public readonly struct MachineRecipeOutput {
		public readonly int type;
		public readonly int stack;
		public readonly double chance;

		public MachineRecipeOutput(int type, int stack, double chance = 1.0) {
			this.type = type;
			this.stack = stack;
			this.chance = Utils.Clamp(chance, 0, 1);
		}
	}
}
