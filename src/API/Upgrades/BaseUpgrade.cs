using SerousEnergyLib.API.Fluid;
using SerousEnergyLib.API.Machines;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Terraria.ModLoader;

namespace SerousEnergyLib.API.Upgrades {
	/// <summary>
	/// The base type for an upgrade that can be placed in a machine
	/// </summary>
	public abstract class BaseUpgrade : ModType {
		/// <summary>
		/// The unique ID for this upgrade type
		/// </summary>
		public int Type { get; protected private set; }

		/// <summary>
		/// The translations for the display name of this upgrade.
		/// </summary>
		public ModTranslation DisplayName { get; private set; }

		/// <summary>
		/// The translations for the tooltip of this item.
		/// </summary>
		public ModTranslation Tooltip { get; private set; }

		/// <summary>
		/// How many instances of this upgrade are permitted on any machine
		/// </summary>
		public abstract int MaxUpgradesPerMachine { get; }

		#pragma warning disable CS1591
		protected sealed override void Register() {
			ModTypeLookup<BaseUpgrade>.Register(this);

			DisplayName = LocalizationLoader.GetOrCreateTranslation(Mod, $"MachineUpgradeName.{Name}");
			Tooltip = LocalizationLoader.GetOrCreateTranslation(Mod, $"MachineUpgradeTooltip.{Name}", true);

			Type = UpgradeLoader.Register(this);
		}

		public sealed override void SetupContent() {
			AutoStaticDefaults();
			SetStaticDefaults();
		}

		/// <summary>
		/// Automatically sets certain static defaults. Override this if you do not want the properties to be set for you.
		/// </summary>
		public virtual void AutoStaticDefaults() {
			if (DisplayName.IsDefault())
				DisplayName.SetDefault(Regex.Replace(Name, "([A-Z])", " $1").Trim());
		}

		/// <summary>
		/// Whether this upgrade can be applied to the specified machine
		/// </summary>
		public abstract bool CanApplyTo(IMachine machine);

		/// <summary>
		/// Return a modifier for power conumption in an <see cref="IPoweredMachine"/> here
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		public virtual StatModifier GetPowerConsumptionMultiplier(int upgradeStack) => StatModifier.Default;

		/// <summary>
		/// Return a modifier for power generation in an <see cref="IPowerGeneratorMachine"/> here
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		public virtual StatModifier GetPowerGenerationMultiplier(int upgradeStack) => StatModifier.Default;

		/// <summary>
		/// Return a modifier for the maximum power capacity in an <see cref="IPoweredMachine"/> here
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		public virtual StatModifier GetPowerCapacityMultiplier(int upgradeStack) => StatModifier.Default;

		/// <summary>
		/// Return a modifier for the maximum fluid storage capacity for a fluid storage in an <see cref="IFluidMachine"/> here
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		public virtual StatModifier GetFluidCapacityMultiplier(int upgradeStack) => StatModifier.Default;

		/// <summary>
		/// Return an addition to the item stack generated by an <see cref="IItemOutputGeneratorMachine"/> here
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		/// <param name="originalStack">The item stack before applying this upgrade</param>
		public virtual int GetItemOutputGeneratorExtraStack(int upgradeStack, int originalStack) => 0;

		/// <summary>
		/// Return a modifier for the fluid product quantity generated by an <see cref="IFluidOutputGeneratorMachine"/> here
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		/// <param name="fluidType">The <see cref="FluidTypeID"/> being generated</param>
		public virtual StatModifier GetFluidOutputGeneratorProductMultiplier(int upgradeStack, int fluidType) => StatModifier.Default;

		/// <summary>
		/// Return a modifier for luck chance here.  This method is intended to be paired with <c>Main.rand.NextDouble()</c> with a range of [0, 1]
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		public virtual StatModifier GetLuckPercentageMultiplier(int upgradeStack) => StatModifier.Default;

		/// <summary>
		/// Return whether <paramref name="itemType"/> should be blocked from being generated by an <see cref="IItemOutputGeneratorMachine"/><br/>
		/// If any upgrades in the machine return <see langword="true"/> in this method, the item will not be added to its export inventory
		/// </summary>
		/// <param name="upgradeStack">How many instances of this upgrade are stored in the machine</param>
		/// <param name="itemType">The item type that the machine is trying to generate</param>
		public virtual bool BlockItemOutputGeneratorOutput(int upgradeStack, int itemType) => false;

		/// <summary>
		/// Modify the <paramref name="ingredient"/> within a <see cref="MachineRecipe"/> with the given <paramref name="possibleOutputs"/> here
		/// </summary>
		/// <param name="ingredient">The ingredient for the recipe</param>
		/// <param name="defaultIngredients">A collection of the original ingredients that the recipe contains</param>
		/// <param name="possibleOutputs">A collection of the possible outputs that the recipe contains</param>
		public virtual void ModifyMachineRecipeIngredient(ref IMachineRecipeIngredient ingredient, IReadOnlyList<IMachineRecipeIngredient> defaultIngredients, IReadOnlyList<MachineRecipeOutput> possibleOutputs) { }
	}
}
